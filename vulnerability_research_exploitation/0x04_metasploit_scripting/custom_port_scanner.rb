#!/usr/bin/env ruby

require 'msf/core'
require 'socket'

class MetasploitModule < Msf::Auxiliary

  # Module metadata
  include Msf::Exploit::Remote::Tcp

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'Custom Port Scanner',
      'Description'    => %q{
        This module scans a range of ports on the target system and identifies which ones are open.
      },
      'Author'         => 'Your Name',
      'License'        => MSF_LICENSE,
      'References'     =>
        [
          ['URL', 'http://www.example.com']
        ],
      'DisclosureDate' => '2024-12-21'
    ))

    register_options(
      [
        Opt::RHOST('RHOST', [true, 'The target address', nil]),
        Opt::RPORT('RPORT', [true, 'The target port', 80]),
        OptInt.new('STARTPORT', [true, 'Starting port number for scan', 1]),
        OptInt.new('ENDPORT', [true, 'Ending port number for scan', 1024])
      ], self.class)
  end

  def run
    rhost = datastore['RHOST']
    startport = datastore['STARTPORT']
    endport = datastore['ENDPORT']

    print_status("Scanning ports #{startport} to #{endport} on #{rhost}...")

    open_ports = []

    (startport..endport).each do |port|
      begin
        sock = Socket.new(:INET, :STREAM)
        sockaddr = Socket.sockaddr_in(port, rhost)
        sock.connect(sockaddr)
        sock.close
        open_ports << port
        print_good("Port #{port} is open on #{rhost}")
      rescue Errno::ECONNREFUSED, Errno::ETIMEDOUT, Errno::EHOSTUNREACH
        # Ignore connection errors (i.e., port is closed or unreachable)
      ensure
        sock.close if sock
      end
    end

    if open_ports.empty?
      print_status("No open ports found on #{rhost}")
    else
      print_status("Open ports on #{rhost}: #{open_ports.join(', ')}")
    end
  end
end
